package net.defplus.trophygen

import java.io.BufferedWriter
import scala.xml.XML
import scala.xml.Xhtml
import scala.xml.NodeSeq
import scala.xml.Node
import java.io.FileWriter
import java.io.File
import scala.xml.PrettyPrinter

object Trophygen {

  // 単体で起動するためのメインメソッド
  def main(args: Array[String]) {
    val out = new BufferedWriter(new FileWriter(new File(TARGET_HTML_PATH)))
    out.write(xhtml())
    out.close()
    println("Achievement System HTML was gererated by Trophygen.")
  }

  // 入力となるOPMLのパス 絶対パスも可(例：/user/yourname/pages/sample.opml)
  val SOURCE_OPML_PATH = "resource/sample.opml"
  // 出力するHTMLのパス 
  val TARGET_HTML_PATH = "resource/sample.html"

  //   OPMLからXHTMLソースを生成する。
  def xhtml() = {

    // 指定したパスに存在するOPMLをプログラム上でXMLとして読み込みます。
    // Scalaの標準ライブラリにはXMLを扱うscala.xmlパッケージがあり便利です。
    val opml = XML.load(SOURCE_OPML_PATH)

    // OPMLは、XMLの一種でツリー構造をしています。
    // 実績チェック用のOPMLは上の階層から順に
    // カテゴリー → プロジェクト → タスクリスト → タスク
    // という情報を保持しています。
    // (sample.opml を見るのが手っ取り早いかも。)

    // プログラム全体の流れはこんな感じ。
    //  1-1.OPMLからカテゴリーの集合を取り出します。{
    //   2-1.カテゴリーからプロジェクトの集合を取り出します。{
    //    3-1.プロジェクトからタスクリストの集合を取り出します。{
    //     4-1.タスクリストからタスクの集合を取り出します。{
    //      5.タスクの(HTML,割当スコア,獲得スコア)を生成し戻します。
    //     } ← 4-2.タスクの(HTML,割当スコア,獲得スコア)を集積してタスクリスクの(HTML,割当スコア,獲得スコア)を生成します。
    //    } ← 3-2.タスクリストの(HTML,割当スコア,獲得スコア)を集積してプロジェクトの(HTML,割当スコア,獲得スコア)を生成します。
    //   } ← 2-2.プロジェクトの(HTML,割当スコア,獲得スコア)を集積してカテゴリーの(本文HTML,要約部HTML,割当スコア,獲得スコア)を生成します。
    //  } ← 1-2.カテゴリーの(本文HTML,要約部HTML,割当スコア,獲得スコア)を集積して実績システム全体のHTMLを生成します。
    // めでたく目的のHTMLができました。ばんざーい。ばんざーい。
    //
    // ※プロジェクトの下にはタスクリストの代わりにタスクを置くことも許しているので
    // 　その場合は4の階層が省略されます。

    // 1-1.一番上の階層にあるカテゴリーの集合を取り出します。
    val categories = (opml \\ "body" head) \ "outline"

    //1-2.カテゴリーの(本文HTML,要約部HTML,割当スコア,獲得スコア)を集積します。
    val (categories_html, summary_html, allocated_score, acquired_score) =
      ((NodeSeq.Empty, NodeSeq.Empty, 0, 0) /: categories.map(info_of_category(_)))(
        (a, b) => (a._1 ++ b._1, a._2 ++ b._2, a._3 + b._3, a._4 + b._4))

    // 総獲得スコアから「称号（ランク）」と次の称号獲得までの必要スコアを求めます。
    val (score_rank, next_target_score) = ScoreRank.check(acquired_score)
    val score_for_next_rank = next_target_score - acquired_score

    //実績システム全体のHTMLを生成します。
    val html = <html xmlns="http://www.w3.org/TR/xhtml11">
                 <head profile="http://gmpg.org/xfn/11">
                   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
                   <title>Achievement System of Myself (generated by Trophygen)</title>
                   <link rel="stylesheet" href="sample.css" type="text/css"/>
                 </head>
                 <body>
                   <div id="content">
                     "Achievement System of Myself"
                     <p id="scoreboard">
                       { "My Rank is " }<strong>{ score_rank }</strong><br/>
                       { "My Score is " }<strong>{ acquired_score + " points" }</strong><br/>
                       { "Need more " }<strong>{ score_for_next_rank + " points" }</strong>{ " for Next Rank" }
                     </p>
                     <br/>
                     <div id="scorepanes">
                       { summary_html }
                       { categories_html }
                     </div>
                   </div>
                   <div id="footer"> Achievement System of Myself (generated by Trophygen) </div>
                 </body>
               </html>

    // HTMLを整形します。
    new PrettyPrinter(80, 2).format(html)
    // 実績システム全体のHTMLを戻します。
    Xhtml.toXhtml(html)
  }

  // 2.カテゴリーの(HTML,要約部HTML,割当スコア,獲得スコア)を生成し戻します。
  def info_of_category(category: Node): (NodeSeq, NodeSeq, Int, Int) = {

    // 2-1.カテゴリーからプロジェクトの集合を取り出します。
    val projects = category \ "outline"

    // 2-2.プロジェクトの(HTML,割当スコア,獲得スコア)を集積します。
    // 通常のプロジェクトと完了済み(獲得スコア＝割当スコア)のプロジェクトは別々に集積しています。
    val (category_main_html, category_report_html, allocated_score, acquired_score, completed_project_score) =
      ((NodeSeq.Empty, NodeSeq.Empty, 0, 0, 0) /: projects.map(info_of_project(_)))(
        (a, b) => (
          if (b._2 == b._3) {
            (a._1, a._2 ++ b._1, a._3 + b._2, a._4 + b._3, a._5 + b._3)
          } else {
            (a._1 ++ b._1, a._2, a._3 + b._2, a._4 + b._3, a._5)
          }
        )
      )

    // 属性"text"の項の文字列をカテゴリーの名前として表示します。
    val name = category.attribute("text").getOrElse("none").toString()

    // カテゴリ毎の目標スコア
    val MAX_TARGET_SCORE_FOR_CATEGORY = 100000

    // 総獲得スコアとカテゴリ毎の目標スコアの比をとり、100分率ゲージに表示します。（初期設定では緑色、CSSで変えられます）
    val completed = if (acquired_score > MAX_TARGET_SCORE_FOR_CATEGORY) 100
    else getRateByPercent(acquired_score, MAX_TARGET_SCORE_FOR_CATEGORY)
    // 未獲得の割当スコア合計とカテゴリ毎の目標スコアの比をとり、100分率ゲージに別色で表示します。（デフォルトは灰色、CSSで変えられます）
    val ongoing = if (acquired_score > MAX_TARGET_SCORE_FOR_CATEGORY) 100 - completed
    else getRateByPercent(allocated_score - acquired_score, MAX_TARGET_SCORE_FOR_CATEGORY)

    // カテゴリーの要約部のHTMLを生成します。
    // 要約部は実績ページの上部に表示します。
    val summary =
      <div class="categorysummary">
        <div class="progress_rate">
          <span class="completed" style={ "width: " + completed + "%" }></span>
          <span class="ongoing" style={ "width: " + ongoing + "%" }></span>
        </div>
        { name + "    " + acquired_score + " pts / " + allocated_score + " pts" }
      </div>
    // カテゴリーのHTMLを生成します。
    // 完了済みプロジェクトは簡易表示にして下部にまとめて表示します。
    val html =
      <input type="radio" name="tab" class="radio" value={ name }/>
      <div class="category">
        { category_main_html }
        <p class="report">
          <strong>{ "[[ Completed Project ]]      Total Score => " + completed_project_score + " points" }</strong>
          { category_report_html }
        </p>
      </div>
    //カテゴリーの(HTML,割当スコア,獲得スコア)を戻します。
    (html, summary, allocated_score, acquired_score)
  }

  // 3.プロジェクトの(HTML,割当スコア,獲得スコア)を生成し戻します。
  def info_of_project(project: Node): (NodeSeq, Int, Int) = {

    // 3-1.プロジェクトからタスクリストの集合を取り出します。
    // ※プロジェクトの下にはタスクリストの代わりにタスクを置くことも許されているので、
    // 　子に要素をもたないタスクリストがプロジェクトに含まれている場合はそのタスクリストを単体タスクと見なします。
    // 　単体タスクについては、4.タスクリストの処理をスキップして、5.タスクの処理を行います。
    val info_of_tasklists = {
      val tasklists = project \ "outline"
      tasklists.filter(_.child.size == 0).map(info_of_task(_)) ++ tasklists.filter(_.child.size != 0).map(info_of_tasklist(_))
    }

    // 3-2.タスクリストの(HTML,予定P,獲得済P)を集積します。
    val (project_html, allocated_score, acquired_score) =
      ((NodeSeq.Empty, 0, 0) /: info_of_tasklists)((a, b) => (a._1 ++ b._1, a._2 + b._2, a._3 + b._3))

    // 属性"text"の項の文字列をプロジェクトの名前として表示します。
    val project_name = project.head.attribute("text").getOrElse("none").toString()

    // 割当スコアと獲得スコアのパーセント比を求め、棒グラフの表示に利用します。
    val progress_rate = getRateByPercent(acquired_score, allocated_score)

    // プロジェクトのHTMLを生成します。
    // プロジェクトが完了済み（＝全ての割当スコアを獲得済み）の場合はタスクリストを隠して簡易表示にします。
    // 完了済みプロジェクトもタスクリストを表示したい場合はif(false)とでもしてください（
    val html = if (allocated_score == acquired_score) {
      <div class="th report">
        <div class="td reportname">{ "[[ " + project_name + " ]]" }</div>
        <div class="td reportscore">{ allocated_score + " points acquired." }</div>
      </div>
    } else {
      <p class="project">
        <strong>{ project_name }</strong>{ "        project score : " + acquired_score + " pts / " + allocated_score + " pts" }
        <div class="progress_rate"><div style={ "width: " + progress_rate + "%" }></div></div>
        <table>
          <div class="th">
            <div class="td unlocked">✔</div>
            <div class="td name">task title</div>
            <div class="td score">points</div>
          </div>
          { project_html }
        </table>
      </p>
    }
    //プロジェクトの(HTML,割当スコア,獲得スコア)を戻します。
    (html, allocated_score, acquired_score)
  }

  // 4.タスクリストの(HTML,割当スコア,獲得スコア)を生成し戻します。
  def info_of_tasklist(tasklist: Node): (NodeSeq, Int, Int) = {

    // 4-1.タスクリストからタスクの集合を取り出します。
    val tasks = tasklist \ "outline"

    // 4-2.タスクの(HTML,割当スコア,獲得スコア)を集積します。
    val (tasks_html, allocated_score, acquired_score) =
      ((NodeSeq.Empty, 0, 0) /: tasks.map(info_of_task(_)))((a, b) => (a._1 ++ b._1, a._2 + b._2, a._3 + b._3))

    // タスクリストが完了しているか否かでテーブル行divに別クラスを与えます。(CSSで色分けするために)
    val tasklist_status = if (allocated_score == acquired_score) "th completed" else "th ongoing"

    // タスクリストが完了していたらチェックマーク(✔)を表示します。
    val mark_of_unlocked = if (allocated_score == acquired_score) "✔" else ""

    // 属性"text"の項の文字列をタスクリストの名前として表示します。
    val tasklist_name = tasklist.head.attribute("text").getOrElse("none").toString()

    // タスクリストのHTMLを生成します。
    val html =
      <input type="checkbox" class="checkbox"/>
      <div class="multi">
        <div class={ tasklist_status }>
          <div class="td unlocked">{ mark_of_unlocked }</div>
          <div class="td name">{ "[ " + tasklist_name + " ]" }</div>
          <div class="td score">{ "[ " + acquired_score + " / " + allocated_score + " pts ]" }</div>
        </div>
        { tasks_html }
      </div>

    // タスクリストの(HTML,割当スコア,獲得スコア)を戻します。
    (html, allocated_score, acquired_score)
  }

  // 5.タスクの(HTML,割当スコア,獲得スコア)を生成し戻します。
  def info_of_task(task: Node): (NodeSeq, Int, Int) = {

    // チェックボックスにチェックが入ってたら(属性"_status"の値が"checked"なら) 
    // タスクは完了したものとみなします。
    val task_completed = task.attribute("_status").getOrElse("none").toString() == "checked"

    // タスクが完了しているか否かでテーブル行divに別クラスを与えます。(CSSで色分けするために)
    val task_status = if (task_completed) "tr completed" else "tr ongoing"

    // タスクが完了していたらチェックマーク(✔)を表示します。
    val mark_of_unlocked = if (task_completed) "✔" else ""

    // 属性"text"の項の文字列をタスクの名前として表示します。
    val task_name = task.attribute("text").getOrElse("none").toString()

    // 属性"pts"の項の数値を割当スコアとします。
    val allocated_score = task.attribute("pts").getOrElse("0").toString().toInt

    // タスクが完了していたら獲得スコアに割当スコアを代入します。
    // タスクが完了していなければ獲得スコアは０です。
    val acquired_score = if (task_completed) allocated_score else 0

    // タスクのHTMLを生成します。
    val html =
      <div class={ task_status }>
        <div class="td unlocked">{ mark_of_unlocked }</div>
        <div class="td name">{ task_name }</div>
        <div class="td score">{ acquired_score + " / " + allocated_score + " pts" }</div>
      </div>

    // タスクの(HTML,割当スコア,獲得スコア)を戻します。
    (html, allocated_score, acquired_score)
  }

  // dividend÷divisorの結果を百分率で返すヘルパメソッド
  // カテゴリやプロジェクトごとのスコア獲得率ゲージの表示に使います。
  // ユーザがタスクにpointsを指定し忘れることを想定し、
  // divisorが0の場合は0を返すようにしてあります。
  def getRateByPercent(dividend: Int, divisor: Int): Int = {
    if (divisor == 0) return 0
    dividend * 100 / divisor
  }

}